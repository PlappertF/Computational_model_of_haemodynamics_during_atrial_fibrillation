import numpy as np
import warnings
from pathlib import Path
from numba import njit
import matplotlib.pyplot as plt
import seaborn as sns
import pickle
import os
import uuid
import shutil
import pathlib

from src.avn import rmssd, sample_entropy
from src.activation import assess_model_phase, update_activation
from src.check_input import check_input_params
from src.init import format_input_params
from src.import_export import export_sim
from src.utils import get_outputs


def rhythm_is_a_dancer(model, rhythm='AF', num_beats=5, num_beats_af_launch=10, num_draw_beats_at_once=np.inf, fs=2000,
                       avn_p4_params=None, desired_rr_char=None, desired_vat_series=None,
                       patch_t_delay=np.concatenate([np.zeros(21), -120 * np.ones(2)]), n_patches_atria=1,
                       act_sigma_atria=0, act_sigma_ventr=0, keep_simulation_data='all', use_converged=True,
                       check_params=True, batch_size=400000, show_termination_warning=False, file_path=None,
                       file_name=None):
    """
    This function is the main entry point for the rhythm module.
    Heart rhythms can be set up in this function call in 5 different ways:
    1. num_beats=Given, avn_p4_params=None, desired_rr_char=None and desired_vat_series=None: This is allowed when
           rhythm='AF', but is not allowed when rhythm='NSR'. In this case, a random parameter set for the AVN model and
           the Pearson Type IV distribution is drawn each time the rhythm_is_a_dancer function is called. The VAT series
           (ventricular activation time series) with N beats given by num_beats will be generated DURING the MultiPatch
           simulation and each time the ventricles are stimulated, the next ventricular activation time is drawn.
    2. num_beats=Given, avn_p4_params=Given, desired_rr_char=None and desired_vat_series=None: This is allowed when
           rhythm='AF', but is not allowed when rhythm='NSR'. It is similar to the first case, but the parameter set for
           the AVN model and the Pearson Type IV distribution is given by the user instead of randomly drawn before the
           MultiPatch simulation. A ventricular activation time (VAT) series with N beats given by num_beats will be
           generated DURING the MultiPatch simulation.
    3. num_beats=Given, avn_p4_params=None, desired_rr_char=Given and desired_vat_series=None: This is allowed for both
           rhythm='NSR' and rhythm='AF'. For normal sinus rhythm (NSR), the way to set the mean heart rate or RR mean is
           by passing one value to desired_rr_char (see more details in the :param description below). For atrial
           fibrillation (AF), either just the mean heart rate or RR mean can be passed, or a ndarray with RR mean,
           RR rmssd and RR sample entropy (see more details in the :param description below). Note, that the
           'desired_rr_char' can be used to find AVN model parameters and Pearson Type IV parameters that roughly result
           in the desired RR characteristics. However, a ventricular activation time (VAT) series with N beats given by
           num_beats will be generated DURING the MultiPatch simulation, and it can't be guaranteed that the resulting
           RR series is close enough to the desired RR series characteristics. If you want to run the model with
           RR series with exactly predefined RR series characteristics, it is recommended to generate an RR series
           beforehand and pass it with the used AVN model parameters and Pearson Type IV parameters to the
           'rhythm_is_a_dancer' function (Case 4 in this list).
    4. num_beats=None, avn_p4_params=Given, desired_rr_char=None and desired_vat_series=Given: This is allowed when
           rhythm='AF', but is not allowed when rhythm='NSR'. In this case, the ventricular activation time (VAR) series
           is given by the user BEFORE the MultiPatch simulation and is not generated by the AVN model during the
           MultiPatch simulation. However, to reach the starting point for the simulation where the VAT series is used,
           we need to generate a few beats for the 'NSR launch phase' and 'AF launch phase' requiring the parameter set
           for the AVN model and the Pearson Type IV distribution.
    5. num_beats=None, avn_p4_params=None, desired_rr_char=None and desired_vat_series=Given: This is allowed when
           rhythm='NSR', but is not allowed when rhythm='AF'. In this case, the VAT series is given by the user BEFORE
           the MultiPatch simulation. The desired_vat_series has to be a ndarray with at least two ventricular
           activation times, because the RR mean for the NSR launch phase is calculated as the mean of the RR intervals
           computed from the VAT series.
    :param model: Class object of the model with all parameters.
    :param rhythm: The rhythm to be simulated. Default is 'AF' for atrial fibrillation. Other options are 'NSR' for
                   normal sinus rhythm.
    :param num_beats: Pass a positive integer including 0 as the desired number of beats that should be simulated
                      (default is 5). The 'NSR launch phase' and 'AF launch phase' where the model is run for a few
                      beats to reach a steady state is not included in the num_beats count. The number of beats are
                      counted after the 'launch' phase is finished. I assume that positive integers >= 1 for the number
                      of simulated beats are intuitive to understand. If the number of beats is set to 0 (this case is
                      only allowed when rhythm='NSR'), a special case is triggered, where the model stops after the
                      launch phase and the output is the last beat of the launch phase. This special case was implemented
                      to allow using this new model implementation like the original model implementation. This new model
                      implementation runs the model in continuous time, where an RR interval is not looped. In the new
                      model implementation, the end of the 'launch' phase is triggered when the last two RR intervals are
                      close enough to each other, which basically gives the same result as the original model
                      implementation that ran one RR interval in a loop.
    :param num_beats_af_launch: Number of beats (integer >= 0) during the 'AF launch phase' (default is 10). This
                                parameter is only relevant when the rhythm is set to 'AF'. If the rhythm is 'NSR', a
                                warning will be displayed that this parameter is ignored. Before the 'AF launch phase',
                                there is a 'NSR launch phase', where the ventricular patches contract regularly with a
                                constant RR interval between activation and the atrial patches contract with the same
                                interval between activations but with a delay before the ventricular patches given by
                                'patch_t_delay'. Once the volume trends between two RR intervals are basically repeating
                                themselves, the 'NSR launch phase' ends and the 'AF launch phase' starts if 'rhythm' is
                                'AF'. We evaluate whether the volume trend is repeating itself by checking if the
                                difference between the volumes of two consecutive beats is below a threshold; we check
                                the values at the time the His-bundle theoretically activates.
                                In the 'AF launch phase', the atrial patches start to simulate fibrillation and the
                                ventricular patches are contracting now with an RR series that has the same RR series
                                characteristics as the RR series that will be simulated after the 'AF launch phase'. The
                                'AF launch phase' is a phase to 'forget' the history that the model was running beats
                                mimicking normal sinus rhythm in the 'NSR launch phase'.
    :param num_draw_beats_at_once: Number of ventricular activation times that are drawn at once (must be integer >= 1).
                                   If we want to draw the next ventricular activation based on the current activation
                                   time, then this number has to be 1. However, drawing only one value at once is slower
                                   than drawing multiple values at once (due to overhead), so this setting can be used to
                                   speed up the simulation if it is not necessary to draw the next activation time at the
                                   time of the current activation.
                                   The simulation will only draw as many ventricular activation times as needed. So
                                   num_draw_beats_at_once=np.inf is a valid input, and the simulation will effectively
                                   draw all ventricular activation times before the simulation starts. If
                                   num_draw_beats_at_once is set to a value larger than 1 but smaller than the remaining
                                   ventricular activation times, then the 'num_draw_beats_at_once' are drawn and written
                                   into the vat_series to be used for the next beats. For the next beats, no ventricular
                                   activation time has to be drawn then.
    :param fs: Sampling frequency of the model. Default is 2000 Hz corresponding to a time step of 0.5 ms.
    :param avn_p4_params: Parameters for the AVN model to simulate the AV nodal conduction of an AA series to the
                          ventricles as well as parameters for the Pearson Type IV distribution to generate an AA series
                          as input for the AVN model. If avn_p4_params is None, then a new set of parameters for the
                          AV node and Pearson Type IV distribution is drawn each time the rhythm_is_a_dancer function is
                          called. In this case, we don't know beforehand what the RR mean, RR rmssd and RR sample entropy
                          will be. If we want to run a simulation for a specific parameter set where we know the
                          RR series characteristics beforehand, then this is the way to give the model this parameter
                          set.
                          The format of avn_p4_params is following:
                          avn_p4_params[0]: Minimum refractory period of the slow AV nodal pathway between 250-600ms.
                          avn_p4_params[1]: Range of refractory period of the slow AV nodal pathway between 0-600ms.
                          avn_p4_params[2]: Time constant of the refractory period of the slow AV nodal pathway between
                                            50-300ms.
                          avn_p4_params[3]: Minimum refractory period of the fast AV nodal pathway between 250-600ms.
                          avn_p4_params[4]: Range of refractory period of the fast AV nodal pathway between 0-600ms.
                          avn_p4_params[5]: Time constant of the refractory period of the fast AV nodal pathway between
                                            50-300ms.
                          avn_p4_params[6]: Fixed refractory period of the coupling node of the AV node model set to
                                            250ms.
                          avn_p4_params[7]: Minimum conduction delay of the slow AV nodal pathway between 0-30ms.
                          avn_p4_params[8]: Range of conduction delay of the slow AV nodal pathway between 0-75ms.
                          avn_p4_params[9]: Time constant of the conduction delay of the slow AV nodal pathway between
                                            50-300ms.
                          avn_p4_params[10]: Minimum conduction delay of the fast AV nodal pathway between 0-30ms.
                          avn_p4_params[11]: Range of conduction delay of the fast AV nodal pathway between 0-75ms.
                          avn_p4_params[12]: Time constant of the conduction delay of the fast AV nodal pathway between
                                             50-300ms.
                          avn_p4_params[13]: Fixed conduction delay of the coupling node of the AV node model set to 0ms.
                          avn_p4_params[14]: Amplitude of the respiratory modulation of the AV node model between
                                             -0.1 and 0.5.
                          avn_p4_params[15]: Frequency of the respiratory modulation of the AV node model between 0-10Hz.
                          avn_p4_params[16]: Mean arrival rate of atrial impulses used in the Pearson Type IV
                                             distribution between 100-250ms.
                          avn_p4_params[17]: Standard deviation of the arrival rate of atrial impulses used in the
                                             Pearson Type IV distribution between 15-30ms.
                          avn_p4_params[18]: Skewness of the arrival rate of atrial impulses used in the Pearson Type IV
                                             distribution set to 1.
                          avn_p4_params[19]: Kurtois of the arrival rate of atrial impulses used in the Pearson Type IV
                                             distribution set to 6.
                          avn_p4_params[20]: Lower limit of intervals between atrial impulses that are drawn from the
                                             Pearson Type IV distribution set to 50ms. Below this limit, an interval is
                                             discarded and a new interval is drawn as replacement.
    :param desired_rr_char: Desired RR series characteristics. The parameter 'desired_rr_char' has different rules
                            depending on the 'rhythm' parameter.
                            If 'rhythm' is 'NSR', the parameter has to be a single value (int or float) larger or equal
                            to 12 and smaller or equal to 200, or larger or equal to 250 and smaller or equal to 5000.
                             -  If the parameter is larger or equal than 12 and smaller or equal to 200, then it is
                                assumed that the parameter is the desired mean heart rate in bpm. If the parameter is
                                larger or equal to 250 and smaller or equal to 5000, then it is assumed that the
                                parameter is the desired RR mean in milliseconds. Between 200 and 250, a ValueError is
                                raised.
                            If 'rhythm' is 'AF', the parameter can either be None, a single value (int or float) or a
                            ndarray with three values.
                             -  If the parameter is None, then the function will generate a random parameter set for the
                                AVN model and the Pearson Type IV distribution each time 'rhythm_is_a_dancer' is called.
                             -  If the parameter is a single value, it needs to be again a value larger or equal than 12
                                or smaller or equal than 5000. If the parameter is larger than or equal than 12 and
                                smaller or equal to 200, then it is assumed that the parameter is the desired mean heart
                                rate. If the parameter is larger or equal to 250 and smaller or equal to 5000, then it is
                                assumed that the parameter is the desired RR mean in milliseconds. Between 200 and 250, a
                                ValueError is raised. The code will generate new parameter sets and RR series with 1000
                                RR intervals in a while loop until the RR series matches the desired mean heart rate
                                +- 1 bpm or the desired RR mean +- 10 ms. Note, that the RR series will not be used in
                                the simulation as the simulation is drawing individual RR intervals when needed. Also
                                note, that it might not be possible to generate an RR series with the desired mean heart
                                rate or RR mean, and the code will display a warning after every 100 iterations but will
                                not stop automatically.
                             -  If the parameter is a ndarray with three values, then the first value refers to the
                                RR mean with allowed values between 250-5000. The second value refers to the RR rmssd
                                of the RR series and is allowed to be between 0-1000 (more realistic is between 40-500).
                                The third value is the RR sample entropy and is allowed to be between 0-5 (more realistic
                                is between 0.5-2.3). The code will generate new parameter sets and RR series with 200
                                RR intervals in a while loop until the RR series matches the desired RR mean +- 10 ms,
                                the desired RR rmssd +- 10 ms and the desired RR sample entropy +- 0.1. Note, that the
                                RR series will not be used in the simulation as the simulation is drawing individual
                                RR intervals when needed. Also note, that it might not be possible to generate an
                                RR series with the desired RR series characteristics, and the code will display a warning
                                after every 100 iterations but will not stop automatically.
    :param desired_vat_series: Desired ventricular activation time (VAT) series. The parameter 'desired_vat_series' can
                               either be None, or an integer, float or ndarray of values corresponding to the ventricular
                               activation times in milliseconds. The values in the ndarray have be >=0, increase in value
                               and the minimum difference has to be 250 ms and the maximum difference has to be 5000 ms.
    :param patch_t_delay: Time delay of each MultiPatch model patch relative to the ventricular activation time from the
                          VAT series. The expected shape of the patch_t_delay parameter is (23,). The first 21 values are
                          activation times for the ventricular patches. The default is that all 21 ventricular patches
                          are zero and therefore activate at the same time given by the VAT series. Passing a custom
                          Numpy array allows you to predefine how the electrical excitation is propagating over the
                          ventricles either during normal sinus rhythm or during atrial fibrillation. The default is that
                          the 2 atrial patches are -120 and therefor activate 120ms before the activation times given by
                          the VAT series. If an element in patch_t_delay is np.inf, then this patch will never contract
                          throughout all NSR launch phase, AF launch phase and the real simulation. If 'rhythm'='NSR',
                          the delay in the atrial patches is used in both the 'NSR launch phase' and during the actual
                          simulation. If 'rhythm'='AF', the delay in the atrial patches is used for the
                          'NSR launch phase', as the activation times are then drawn from a stochastic point process
                          instead to simulate fibrillation. If the delay in an atrial patch is set to np.inf, then the
                          whole atria will only be described by 1 atrial patch that will never contract to keep the
                          simulation as simple as it can be. In this case, the value of 'n_patches_atria' for this
                          atrium will be ignored. It can be possible, that one atrium can have electrical contraction, but
                          the other atrium never contracts.
    :param n_patches_atria: For each atrium, the sphere is divided into N patches of equal size, where N is
                            n_patches_atria. Each patch gets its own MultiPatch parameters and activation times. The
                            n_patches_atria parameter is used to set up the MultiPatch model in the init_multipatch
                            function. Default is 1. The n_patches_atria can be set to a value larger than 1 to simulate
                            the independent electrical activation of different areas of the atria.
    :param act_sigma_atria: Standard deviation of the atrial activation times in milliseconds. Default is 0. The atrial
                            activation standard deviation can only be set in normal sinus rhythm and not in AF. It adds
                            to the patch_t_delay of the atrial patches a zero-mean Gaussian sample with the standard
                            deviation set to act_sigma_atria.
    :param act_sigma_ventr: Standard deviation of the ventricular activation times in milliseconds. Default is 0. The
                            ventricular activation standard deviation can be set in both normal sinus rhythm and atrial
                            fibrillation. It adds to the VAT series a zero-mean Gaussian sample with the standard
                            deviation set to act_sigma_ventr.
    :param keep_simulation_data: The parameter 'keep_simulation_data' can be set to 'all' or 'no_launch'.
                                 If 'keep_simulation_data' is set to 'all', then all iterations from the 'NSR launch
                                 phase', 'AF launch phase' and the real simulation are saved from the batches and stored
                                 in the model object. If 'keep_simulation_data' is set to 'no_launch', then the
                                 iterations from the 'NSR launch phase' and 'AF launch phase' are discarded and only the
                                 real simulation is saved from the batches and stored in the model object. In the special
                                 case where rhythm='NSR' and num_beats=0, the last beat of the 'NSR launch phase' is
                                 stored in the model object.
    :param use_converged: Boolean, True or False. If True, the cardiogrowth model starts with a converged solution loaded
                          from 'io/converged_rhythm.pkl'. The converged solution file contains converged solutions for
                          each integer heart rate between 12 and 200. Depending on the RR mean of the planned simulation,
                          the converged solution with the closest heart rate is chosen. If False, no converged solution
                          is loaded and the cardiogrowth model starts with the default model parameters.
                          Using the converged solution can speed up the simulation as the NSR launch phase will usually
                          take less beats to reach steady state.
    :param check_params: Boolean, True or False. The first step in this 'rhythm_is_a_dancer' function is to check whether
                         all input parameters have the correct format and values that make sense and are allowed. These
                         checks take some time, but may prevent loosing much more time when running the simulation with
                         a typo in the input parameters. However, if you are sure that the input parameters are correct,
                         you can set this check_params flag to False, and the check_input_params function will be skipped
                         to make the simulation a bit faster.
    :param batch_size: Number of beats to simulate in one batch before the whole batch is saved to a file.
                       Default is 400000. This parameter does not have to be set manually and can always be 400000. In a
                       simulation in the 'experiments/find_optimal_batch_size.ipynb' notebook, I found that the batch
                       size of 400000 is performing well over a range of simulation lengths.
    :param show_termination_warning: True if you want to print a warning message if the simulation was terminated. False,
                                     if you don't want to print a warning message if the simulation was terminated.
    :param file_path: Used to export simulation results for cardiomatch. Default is None. Only if file_path and file_name
                      are given, the simulation results are saved.
    :param file_name: Used to export simulation results for cardiomatch. Default is None. Only if file_path and file_name
                      are given, the simulation results are saved.
    :return: All the simulation parameter and simulation results are stored in the cardiogrowth model object.
    """
    # First of all, we make sure that the input parameters have expected values and types. Otherwise, we raise an
    # exception if the input is not as expected.
    if check_params:
        check_input_params(rhythm, num_beats, num_beats_af_launch, num_draw_beats_at_once, fs, batch_size, avn_p4_params,
                           desired_rr_char, desired_vat_series, patch_t_delay, n_patches_atria, act_sigma_atria,
                           act_sigma_ventr, keep_simulation_data, use_converged)

    # Now, we format the input parameters, either to speed up the computation or to enforce that numbers are floats
    # instead of integers.
    (rhythm, fs, desired_rr_char, desired_vat_series, patch_t_delay, n_patches_atria, act_sigma_atria,
     act_sigma_ventr, keep_simulation_data) = (
        format_input_params(
            rhythm, fs, desired_rr_char, desired_vat_series, patch_t_delay, n_patches_atria, act_sigma_atria,
            act_sigma_ventr, keep_simulation_data))

    # Now, we initialize the MultiPatch module parameters. Some of the parameters were previously initialized when
    # creating the CardioGrowth class object. Here, all the parameters are initialized whose size depend on the number
    # of patches in the MultiPatch model description.
    model.initialize_multipatch(fs, patch_t_delay, n_patches_atria)

    # Now, we initialize the activation dataclass containing the model parameters used to generate or manage the heart
    # rhythm for the simulation.
    model.initialize_activations(rhythm, num_beats, num_beats_af_launch, num_draw_beats_at_once, avn_p4_params,
                                 desired_rr_char, desired_vat_series, act_sigma_atria, act_sigma_ventr,
                                 keep_simulation_data, use_converged)

    # Now, we initialize all parameters that are returned after the simulation and whose size depends on the number of
    # iterations in a batch. We divide the simulation into batches to avoid that the memory is overloaded for long
    # simulation.
    model.initialize_batch(rhythm, batch_size)

    # Now, it is time to run the simulation. To read the code, jump to 'run_simulation', because 'call_simulation' is
    # just a wrapper function to write the model parameters from the class object into parameters that numba can handle.
    call_simulation(model)

    # Export result if desired
    if file_name and file_path:
        if not model.termination.terminated:
            model.do_all_post_processing()
            # The model.termination.terminated flag can also be set in the 'do_all_post_processing' function.
            if not model.termination.terminated:
                model.outputs = get_outputs(model)
                export_sim(model, file_path, file_name)
            else:
                model.termination.message += " The model results were not saved."
                if show_termination_warning:
                    print("Warning: " + model.termination.message)
        else:
            model.termination.message += " The model results were not saved."
            if show_termination_warning:
                print("Warning: " + model.termination.message)
            with open(os.path.join(file_path, file_name + ".log"), "w") as f:
                f.write(model.termination.message)
    else:
        if model.termination.terminated:
            if show_termination_warning:
                print("Warning: " + model.termination.message)


@njit(cache=False)
def run_simulation(volumes, pressures, lab_f__h, sig_f__h, c__h, lsc__h, t_act, rm__h, xm__h, lab_f__p, pressures__p,
                   next_act, act, last_gauss, sigma_ventr, sigma_atria, vat, rr, avn_states, avn_q, phases, vat0_time,
                   dt, contractility, sarcomere_length, tension, patches, iv, bi, v, v_conv, midwall, ca_cap, flags,
                   term_msg, v2p_constants, per_constants, cap, con_constants, phase_constants, act_constants,
                   vol_constants):
    """
    This function is the main simulation function. The simulation repeats iteration by iteration until the condition for
    the end of the real simulation is met, being that the desired amount of beats within the real simulation phase were
    simulated.
    :param volumes: |model.volumes| (batch_size, 8) The volumes in the heart chambers and vessels
        The eight columns relate to {'Vp' 0, 'LA': 1, 'LV': 2, 'As': 3, ' Vs': 4, 'RA': 5, 'RV': 6, 'Ap': 7}
    :param pressures: |model.pressures| (batch_size, 8) The pressures in the heart chambers and vessels
    :param lab_f__h: |model.heart.lab_f| (batch_size, 21 + 2N) The strain for each patch in the MultiPatch description.
        The MultiPatch model always has 21 ventricular patches, and has 2*N atrial patches, where N is the number of
        patches per atrium.
    :param sig_f__h: |model.heart.sig_f| (batch_size, 21 + 2N) The stress for each patch in the MultiPatch description.
    :param c__h: |model.heart.c| (21 + 2N,) The contractility of each patch in the MultiPatch description.
    :param lsc__h: |model.heart.lsc| (21 + 2N,) The contractile element length of each patch in the MultiPatch.
    :param t_act: |model.activation.t_act| (21 + 2N, M) The activation time of each patch in the MultiPatch model.
        M is the number of activations that are evaluated at the same time. More information about this can be found in
        the docstring of the 'initialize_activations' function.
    :param rm__h: |model.heart.rm| (batch_size, 5) ?
    :param xm__h: |model.heart.xm| (batch_size, 3) ?
    :param lab_f__p: |model.pericardium.lab_f| (batch_size,) The strain of the pericardium.
    :param pressures__p: |model.pericardium.pressure| (batch_size,) The pressure in the pericardium.
    :param next_act: |model.activation.next_his_activation_time| (scalar) The next activation time of the His-bundle.
        Because each patch can have a different activation time for the same heart beat, we use this parameter to keep
        track of how many beats have been simulated.
    :param act: |model.activation.his_activation_counter| (3,) This array keeps track of how many beats have been
        simulated during the NSR launch phase, AF launch phase and real simulation phase.
    :param last_gauss: |model.activation.last_gauss| (21 + 2N,) The last Gaussian sample that was added to the activation
        time. We need to consider it when computing the next activation time for each patch.
    :param sigma_ventr: |model.activation.sigma_ventr| (1,) The standard deviation of the ventricular activation times to
        model electrical conduction propagation.
    :param sigma_atria: |model.activation.sigma_atria| (1,) The standard deviation of the atrial activation times to
        model electrical conduction propagation.
    :param vat: |np.concatenate([model.activation.vat_series_af_launch, model.activation.vat_series])|
        (model.activation.num_beats_af_launch + model.activation.num_beats,) The combined VAT series of the AF launch
        phase and real simulation.
    :param rr: |np.concatenate([model.activation.rr_series_af_launch, model.activation.rr_series])|
        (model.activation.num_beats_af_launch + model.activation.num_beats - 1,) The combined RR series of the AF launch
        phase and real simulation.
    :param avn_states: |np.concatenate([model.activation.rt, model.activation.dt, model.activation.aat,
        model.activation.node0_n_imp, model.activation.beats_to_draw])| (47,) State parameters of the AVN model, in case
        His-bundle activation times have to be drawn during the simulation.
    :param avn_q: |model.activation.avn_q| The priority queue of activation times within the AVN model, in case
        His-bundle activation times have to be drawn during the simulation.
    :param phases: |model.activation.phases| (batch_size,) The phase of the simulation. 0 is the NSR launch phase, 1 is
        the AF launch phase and 2 is the real simulation phase.
    :param vat0_time: |model.activation.vat0_time| (scalar) The time of the first VAT in the VAT series.
    :param dt: model.solver.dt (scalar) The time step of the simulation.
    :param contractility: |model.contractility| (batch_size, 21 + 2N) The contracility for each patch in the MultiPatch
        description. The MultiPatch model always has 21 ventricular patches, and has 2*N atrial patches, where N is the
        number of patches per atrium.
    :param patches: |model.heart.patches| (21 + 2N,) An array defining whether a patch belong to the left ventricular free
        wall (0), the right ventricular free wall (1), the septal wall (2), the left atrium (3) or the right atrium (4).
    :param iv: |model.heart.i_ventricles| (21 + 2N,) A boolean array with one value per patch in the MultiPatch model.
        If iv[i] is True, then the patch is a ventricular patch. If iv[i] is False, then the patch is an atrial patch.
    :param bi: |model.solver.batch_inc| (scalar) The index in the batch corresponding to the current iteration of the
        simulation.
    :param v: (8,) Volumes of the previous iteration.
    :param v_conv: (8,) Used in NSR launch phase. Volumes at the last His-Bundle activation time. Used to check if the
        volume trends of two consecutive heart beats are almost the same.
    :param midwall: (6,) Parameters to compute the midwall in the Newton solver of the 'v2p_ventricles' function.
        midwall[0]: model.heart.vs (scalar) - Updated each iteration
        midwall[1]: model.heart.ys (scalar) - Updated each iteration
        midwall[2]: model.heart.dv (scalar) - Updated each iteration
        midwall[3]: model.heart.dy (scalar) - Updated each iteration
        midwall[4]: 0.5 * (model.heart.vw_w[0] + model.heart.vw_w[2]) (scalar) - Constant
        midwall[5]: 0.5 * (model.heart.vw_w[1] + model.heart.vw_w[2]) (scalar) - Constant
    :param ca_cap: (21 + 2N, M). The capacity of the contraction. Float between 0 and 1. I think about it in this way.
        There is a finite amount of calcium that can be released. If ca_cap=0, then all the calcium can be released. If
        ca_cap=1, then no calcium can be released any more. For each patch and activation in the t_act matrix, we will
        track how much of the calcium was released and how much will be restored each iteration for each activation
        separately. The f_rise will be scaled by this capacity so that new calcium can only be released if it exists in
        the storage.
    :param flags: (5,) Boolean flags used to control the simulation. If flags[0] is True, then the simulation is in the NSR
        launch phase. If flags[0] is False and flags[1] is True, then the simulation is in the AF launch phase. If flags[0]
        and flags[1] are False and flags[2] is True, then the real simulation will be simulated.
        flags[0]: |model.activation.flag_launch_nsr| True if an NSR launch phase will be simulated. (Always the case)
        flags[1]: |model.activation.flag_launch_af| True if an AF launch phase will be simulated. (True if AF is simulated,
            False if NSR is simulated)
        flags[2]: |model.activation.flag_simulation| True if the real simulation will be simulated. (Always the case)
        flags[3]: False if rhythm='NSR', True if rhythm='AF'. We use a boolean flag instead of a string comparison because
            a boolean comparison is faster than a string comparison.
        flags[4]: Flag to track whether the simulation was run successfully or was terminated. Default is False. If True,
            then the simulation was terminated for a reason stated in 'term_msg'.
    :param term_msg: Message to inform the user why the simulation was terminated.
    :param v2p_constants: (9, 21 + 2N) Constants used in the 'v2p_ventricles' and 'v2p_atria' functions.
        v2p_constants[0]: model.heart.am_ref (21 + 2N,)
        v2p_constants[1]: model.heart.c_1 (21 + 2N,)
        v2p_constants[2]: model.heart.c_3 (21 + 2N,)
        v2p_constants[3]: model.heart.c_4 (21 + 2N,)
        v2p_constants[4]: model.heart.ls_eiso (21 + 2N,)
        v2p_constants[5]: model.heart.ls_ref (21 + 2N,)
        v2p_constants[6]: model.heart.lsc_0 (21 + 2N,)
        v2p_constants[7]: model.heart.sf_act (21 + 2N,)
        v2p_constants[8]: model.heart.vw (21 + 2N,)
        v2p_constants[9]: model.heart.v_max (21 + 2N,)
    :param per_constants: (7,) Constants used in the 'update_pericardium_pressure' function.
        per_constants[0]: model.pericardium.c_1 (scalar)
        per_constants[1]: model.pericardium.c_3 (scalar)
        per_constants[2]: model.pericardium.c_4 (scalar)
        per_constants[3]: model.pericardium.lab_pre (scalar)
        per_constants[4]: model.pericardium.thickness (scalar)
        per_constants[5]: model.heart.v_tot_0 (scalar)
        per_constants[6]: sum(model.heart.vw_w) (scalar)
    :param cap: (4,) Capacitances for the 'update_pressures' function.
        cap[0]: model.capacitances.cvp (scalar)
        cap[1]: model.capacitances.cas (scalar)
        cap[2]: model.capacitances.cvs (scalar)
        cap[3]: model.capacitances.cap (scalar)
    :param con_constants: (7, 21 + 2N) Constants used in the 'compute_contraction' function.
        con_constants[0]: model.heart.ls_eiso (21 + 2N,)
        con_constants[1]: model.heart.ls_ref (21 + 2N,)
        con_constants[2]: model.heart.lsc_0 (21 + 2N,)
        con_constants[3]: model.heart.t_ad (21 + 2N,)
        con_constants[4]: model.heart.td (21 + 2N,)
        con_constants[5]: model.heart.tr (21 + 2N,)
        con_constants[6]: model.heart.v_max (21 + 2N,)
    :param phase_constants: (4,) Constants used in the 'assess_model_phase' function.
        phase_constants[0]: model.solver.cutoff (scalar)
        phase_constants[1]: model.solver.nsr_launch_iter_max (scalar)
        phase_constants[2]: model.activation.num_beats_af_launch (scalar)
        phase_constants[3]: model.activation.num_beats (scalar)
    :param act_constants: (30,) Constants used in the 'update_activation' function.
        act_constants[0:7]: model.activation.avn_rp (7,) Refractory period parameters of the AVN model
            act_constants[0]: Minimum refractory period of the slow AV nodal pathway between 250-600ms
            act_constants[1]: Range of refractory period of the slow AV nodal pathway between 0-600ms
            act_constants[2]: Time constant of the refractory period of the slow AV nodal pathway between 50-300ms
            act_constants[3]: Minimum refractory period of the fast AV nodal pathway between 250-600ms
            act_constants[4]: Range of refractory period of the fast AV nodal pathway between 0-600ms
            act_constants[5]: Time constant of the refractory period of the fast AV nodal pathway between 50-300ms
            act_constants[6]: Fixed refractory period of the coupling node of the AV node model set to 250ms
        act_constants[7:14]: model.activation.avn_cd (7,) Conduction delay parameters of the AVN model
            act_constants[7]: Minimum conduction delay of the slow AV nodal pathway between 0-30ms
            act_constants[8]: Range of conduction delay of the slow AV nodal pathway between 0-75ms
            act_constants[9]: Time constant of the conduction delay of the slow AV nodal pathway between 50-300ms
            act_constants[10]: Minimum conduction delay of the fast AV nodal pathway between 0-30ms
            act_constants[11]: Range of conduction delay of the fast AV nodal pathway between 0-75ms
            act_constants[12]: Time constant of the conduction delay of the fast AV nodal pathway between 50-300ms
            act_constants[13]: Fixed conduction delay of the coupling node of the AV node model set to 0ms
        act_constants[14:16]: model.activation.avn_resp (2,) Respiratory modulation parameters of the AVN model
            act_constants[14]: Amplitude of the respiratory modulation of the AV node model between -0.1 and 0.5
            act_constants[15]: Frequency of the respiratory modulation of the AV node model between 0-10Hz
        act_constants[16:28]: model.activation.p4dist (12,) Parameters of the Pearson Type IV distribution
            act_constants[16]: (scalar) Mean arrival rate of atrial impulses used in the Pearson Type IV distribution
            act_constants[17]: (scalar) Standard deviation of the arrival rate of atrial impulses used in the Pearson
                Type IV distribution
            act_constants[18]: (scalar) Skewness of the arrival rate of atrial impulses used in the Pearson Type IV
                distribution
            act_constants[19]: (scalar) Kurtosis of the arrival rate of atrial impulses used in the Pearson Type IV
                distribution
            act_constants[20]: (scalar) Lower limit of intervals between atrial impulses that are drawn from the Pearson
                Type IV distribution
            act_constants[21]: (scalar) nu parameter of the Pearson Type IV distribution
            act_constants[22]: (scalar) b parameter of the Pearson Type IV distribution
            act_constants[23]: (scalar) a parameter of the Pearson Type IV distribution
            act_constants[24]: (scalar) lam parameter of the Pearson Type IV distribution
            act_constants[25]: (scalar) M parameter of the Pearson Type IV distribution
            act_constants[26]: (scalar) loggM parameter of the Pearson Type IV distribution
            act_constants[27]: (scalar) invgM parameter of the Pearson Type IV distribution
        act_constants[28]: (scalar) RR mean in milliseconds
        act_constants[29]: (scalar) Number of ventricular activation times that are drawn at once
    :param vol_constants: (10,) Constants used in the 'update_volumes' function.
        vol_constants[0]: model.resistances.rap (scalar)
        vol_constants[1]: model.resistances.ras (scalar)
        vol_constants[2]: model.resistances.rav (scalar)
        vol_constants[3]: model.resistances.rcp (scalar)
        vol_constants[4]: model.resistances.rcs (scalar)
        vol_constants[5]: model.resistances.rmvb (scalar)
        vol_constants[6]: model.resistances.rtvb (scalar)
        vol_constants[7]: model.resistances.rvp (scalar)
        vol_constants[8]: model.resistances.rvs (scalar)
        vol_constants[9]: model.circulation.sbv (scalar)
    """
    batch_size = volumes.shape[0]
    act_sigmas = np.ones(iv.shape)
    act_sigmas[iv] = sigma_ventr
    act_sigmas[~iv] = sigma_atria

    # The simulation runs as long as the 'model.activation.flag_simulation' is True.
    while flags[2] and bi < batch_size:  # model.activation.flag_simulation
        # Calculate stretch 'lab_f' and stress 'sig_f' for all patches
        v_chambers = np.array([v[2], v[6], v[1], v[5]])
        lab_f, sig_f__h[bi], tm, rm, xm__h[bi], midwall[0:4], flags, term_msg = (
            v2p(v_chambers, c__h, lsc__h, midwall, patches, dt, flags, term_msg, v2p_constants))
        lab_f__h[bi], rm__h[bi], tension[bi] = lab_f, rm, tm
        if flags[4]:
            continue

        # Calculate pressure 'p__p' and strain 'lab_f__p' in the pericardium
        p__p, lab_f__p[bi] = update_pericardium_pressure(sum(v_chambers), per_constants)
        pressures__p[bi] = p__p

        # Update pressures in blood vessels and heart chambers
        p = update_pressures(v, tm, rm, p__p, cap)
        pressures[bi] = p

        # Update the contractility c and contractile element length lsc
        c__h, lsc__h, ca_cap = compute_contraction(t_act, ca_cap, lab_f, lsc__h, c__h, dt, con_constants)
        # Set contractility of respective patches to 0 if t_act is np.inf. This can only happen if the delay of a patch
        # relative to the His activation is manually set to np.inf, and is a way to make a patch never contract.
        c__h[np.isinf(t_act[:, -1])] = 0
        contractility[bi], sarcomere_length[bi] = c__h, lsc__h

        # Assess whether one or several of 'NSR launch phase', 'AF launch phase', and real simulation are finished.
        phases[bi] = np.argmax(flags[0:3])  # returns 0 in NSR launch phase, 1 in AF launch phase, 2 in real simulation
        vat0_time += dt
        next_act -= dt
        t_act -= dt
        if next_act <= 0:
            flags, act, v_conv, t_act, term_msg = (
                assess_model_phase(flags, act, v_conv, v, t_act, term_msg, phase_constants))
            # We will use vat0_time after the simulation to get a time vector where t=0 is aligned with the time of the
            # first ventricular activation in the real simulation.
            if act[2] == 1:
                vat0_time = -next_act-dt

        # Update the times when the patches are activated
        if next_act <= 0 or np.any(t_act[:, -1] <= 0):
            next_act, t_act, ca_cap, last_gauss, rr, vat, avn_states, avn_q = (
                update_activation(next_act, t_act, ca_cap, flags, act, last_gauss, rr, vat, avn_states, avn_q, act_constants,
                                  act_sigmas))

        # Update volumes. The order of writing the volumes in volumes[bi] before the update_volumes is correct and should
        # be like this, because we skip the first iteration of the while loop in a way.
        volumes[bi] = v
        v = update_volumes(v, p, dt, vol_constants)

        bi += 1

    return (volumes, pressures, lab_f__h, sig_f__h, c__h, lsc__h, t_act, rm__h, xm__h, lab_f__p, pressures__p, next_act,
            act, last_gauss, vat, rr, contractility, sarcomere_length, tension, avn_states, avn_q, phases, vat0_time, bi,
            v, v_conv, midwall, ca_cap, flags, term_msg)


@njit(cache=False)
def update_volumes(v_slice, p_slice, solv_dt, const):
    """
    Code engine: 4th order Runge-Kutta differential equation solver to calculate
    volumes and pressures at the current time point.
    :param v_slice: The volume at one iteration. At the start of this function, v_slice is the volume of the previous
                    iteration and is then updated here to be the volume of the current iteration.
    :param p_slice: The pressure of the previous iteration. At the very first iteration, when the simulation starts,
                    there was no pressure calculated yet. Due to this, the pressure is not used in the very first
                    iteration.
    :param solv_dt: The time step of the simulation. This is a constant and is not updated in this function.
    :param const:
        const[0:9]: resistances
        const[9]: sbv
    :return: The volume of the current iteration.
    """
    # k1-4
    k1 = dv_combined(p_slice, const[0:9])
    k2 = dv_combined(p_slice + 0.5 * solv_dt / 1000 * k1, const[0:9])
    k3 = dv_combined(p_slice + 0.5 * solv_dt / 1000 * k2, const[0:9])
    k4 = dv_combined(p_slice + solv_dt / 1000 * k3, const[0:9])

    v_slice = v_slice + 1 / 6 * solv_dt / 1000 * (k1 + 2 * k2 + 2 * k3 + k4)

    # Fix 'Volume leakage' by ensuring sum is equal to SBV
    v_slice = v_slice * const[9] / np.sum(v_slice)

    return v_slice


@njit(cache=False)
def update_pressures(v_slice, tm, rm, p__pressure, capacitance):
    return np.array([v_slice[0] / capacitance[0],
                     2 * tm[3] / rm[3] * 7.5e3 + p__pressure,
                     2 * tm[0] / np.absolute(rm[0]) * 7.5e3 + p__pressure,
                     v_slice[3] / capacitance[1],
                     v_slice[4] / capacitance[2],
                     2 * tm[4] / rm[4] * 7.5e3 + p__pressure,
                     2 * tm[1] / np.absolute(rm[1]) * 7.5e3 + p__pressure,
                     v_slice[7] / capacitance[3]])


@njit(cache=False)
def dv_combined(p, r):
    """
    Compile all volume changes
    Pressures:
    p[0]: pressure in pulmonary veins
    p[1]: pressure in left atrium
    p[2]: pressure in left ventricle
    p[3]: pressure in systemic arterial
    p[4]: pressure in systemic veins
    p[5]: pressure in right atrium
    p[6]: pressure in right ventricle
    p[7]: pressure in pulmonary arteries
    Resistances:
    r[0]: resistance rap
    r[1]: resistance ras
    r[2]: resistance rav
    r[3]: resistance rcp
    r[4]: resistance rcs
    r[5]: resistance rmvb
    r[6]: resistance rtvb
    r[7]: resistance rvp
    r[8]: resistance rvs
    """
    return np.array([(p[7] - p[0]) / r[0] \
                     - (p[0] - p[1]) / r[7],  # pulmonary veins
                     (p[0] - p[1]) / r[7] \
                     - (p[1] - p[2]) / r[2] * (p[1] > p[2]) \
                     + (p[2] - p[1]) / r[5] * (p[2] > p[1]),  # left atria
                     (p[1] - p[2]) / r[2] * (p[1] > p[2]) \
                     - (p[2] - p[3]) / r[4] * (p[2] > p[3]) \
                     - (p[2] - p[1]) / r[5] * (p[2] > p[1]),  # left ventricle
                     (p[2] - p[3]) / r[4] * (p[2] > p[3]) \
                     - (p[3] - p[4]) / r[1],  # systemic arterial
                     (p[3] - p[4]) / r[1] \
                     - (p[4] - p[5]) / r[8],  # systemic veins
                     (p[4] - p[5]) / r[8] \
                     - (p[5] - p[6]) / r[2] * (p[5] > p[6]) \
                     + (p[6] - p[5]) / r[6] * (p[6] > p[5]),  # right atrium
                     (p[5] - p[6]) / r[2] * (p[5] > p[6]) \
                     - (p[6] - p[7]) / r[3] * (p[6] > p[7]) \
                     - (p[6] - p[5]) / r[6] * (p[6] > p[5]),  # right ventricle
                     (p[6] - p[7]) / r[3] * (p[6] > p[7]) \
                     - (p[7] - p[0]) / r[0]])  # pulmonary arteries


@njit(cache=False)
def tension_numba(vs, ys, vml, vmr, am0, dadt):
    """
    Wall volumes and area
    """

    # Adjust L and R spherical midwall volumes to satisfy VLV and VRV
    vm = np.array([-vml + vs, vmr + vs, vs])

    # Estimate xm from Eq. 9 from CircAdapt derivation
    # Solving 3rd order polynomial
    v = (3 / np.pi) * np.absolute(vm)
    q = (v + np.sqrt(v ** 2 + ys ** 6)) ** (1 / 3)
    xm = np.sign(vm) * (q - ys ** 2 / q)
    xm[xm == 0] = 0.001

    # calculate midwall area Am and curvature Cm=1/rm
    xm2, ym2 = xm ** 2, ys ** 2
    r2 = xm2 + ym2
    rm = r2 / (2 * xm)
    am = np.maximum(np.pi * r2, 1.001 * am0)

    # calculation of tension T and components Tx, Ty
    tm = (am - am0) / dadt
    txi, tyi = (ym2 - xm2) / r2 * tm, ys / rm * tm
    tref = np.sqrt(sum(tm ** 2))

    tx, ty = sum(txi) / tref, sum(tyi) / tref  # axial and radial tension component

    return tx, ty, tm, rm, xm


@njit(cache=False)
def compute_contraction(t_act, ca_cap, lab_f_slice, lsc, c, dt, const):
    """
    :param const: Matrix with 7 fixed arrays that don't change in the whole simulation.
        const[0]: model.heart.ls_eiso
        const[1]: model.heart.ls_ref
        const[2]: model.heart.lsc_0
        const[3]: model.heart.t_ad
        const[4]: model.heart.td
        const[5]: model.heart.tr
        const[6]: model.heart.v_max
    """
    # const[2]: model.heart.lsc_0
    lsc_norm = lsc / const[2] - 1  # normalized contractile element length
    # const[0]: model.heart.ls_eiso, const[1]: model.heart.ls_ref
    lse_norm = np.maximum((lab_f_slice * const[1] - lsc) / const[0], 0.0001)  # Normalized series elastic element
    # hill-type distribution area
    # The equation to calculate is the integral of the hill-type distribution from 0 to 8.
    # The integral is np.exp(-x)*(-0.02*x**5+0.22*x**4-0.4*x**3-1.2*x**2-2.4*x-2.4)
    # The area then can be calculated as
    # np.exp(-8)*(-0.02*8**5 + 0.22*8**4 - 0.4*8**3 - 1.2*8**2 - 2.4*8 - 2.4) + 2.4 = 2.3807310266532795
    # Instead of calculating the integral each iteration, we will set the value in the code.
    area = 2.3807310266532795
    # The value of the integral at 8 is used often, so we will set the value in the code.
    # np.exp(-8)*(-0.02*8**5 + 0.22*8**4 - 0.4*8**3 - 1.2*8**2 - 2.4*8 - 2.4) = -0.019268973346720286
    frise_integral_8 = -0.019268973346720286

    # normalized time during decay of activation
    # const[3]: model.heart.t_ad, const[4]: model.heart.td
    x = (-t_act - (0.65 + 1.0570 * lsc_norm[:, np.newaxis]) * const[3][:, np.newaxis]) / const[4][:, np.newaxis]
    # Old version of gx
    # gx = 0.5 + 0.5 * np.sin(np.sign(x[:, -2]) * np.minimum(np.pi / 2, np.absolute(x[:, -2])))  # always>0
    # New version of gx
    gx_unscaled = 0.5 + np.sign(x) * 0.5 * np.sin(np.minimum(np.pi / 2, np.absolute(x)))  # always>0
    # Each gx of each activation for each patch is scaled by the calcium released due to this activation.
    # Then the sum of all gx are calculated to get one gx value per patch.
    # If the sum of ca_cap is zero for a patch, then there would be a zero division error. To avoid this, I add 1 to
    # the sum of ca_cap. Because it is divided from single values of ca_cap, the division will still turn out to be zero.
    sum_ca_cap = np.sum(ca_cap, axis=1)
    sum_ca_cap = sum_ca_cap + (sum_ca_cap == 0) * 1.0
    gx = np.sum(gx_unscaled * ca_cap, axis=1) / sum_ca_cap
    # The calcium storage is reduced as an exponential decay for each activation and patch individually, based on the
    # respective gx value.
    ca_cap = ca_cap * (1 - gx_unscaled * dt / const[4][:, np.newaxis])

    # const[5]: model.heart.tr
    x = np.minimum(8, np.maximum(0, -t_act / const[5][:, np.newaxis]))
    # How much of the hill-type distribution is left for each value of x as a percentage between 0 and 1? The maximum
    # with 1e-10 is to avoid division by zero error later.
    dist_left = np.maximum((frise_integral_8 - frise_integral(x)) / area, 1e-10)
    # How much calcium is left in storage for each patch?
    calc_left = 1 - np.sum(ca_cap, axis=1)
    # Scaling factor for frise based on how much calcium is left in storage and how much of the hill-type distribution
    # is left keep calcium in storage for the rest of the activation curve.
    scale_frise = np.minimum(np.maximum(calc_left[:, np.newaxis] / dist_left, 0), 1)
    frise_scaled = (x ** 3 * np.exp(-x) * (8 - x) ** 2 * 0.020) * scale_frise
    # Update the calcium storage. Instead of calculating the integral between x-dt/2 and x+dt/2, we will calculate the
    # area of the slice as the value at x times the width of the slice dt. Since the return of calcium in the gx term is
    # not computed from the area of the hill-type distribution, the inaccuracy is not causing a error that increases over
    # time.
    ca_cap = ca_cap + frise_scaled * dt / const[5][:, np.newaxis] / area
    # Calculate the frise for patch as the sum of all frise caused by the multiple activations.
    frise = np.sum(frise_scaled, axis=1)
    # Old version of frise
    # frise = np.sum(x ** 3 * np.exp(-x) * (8 - x) ** 2 * 0.020, axis=1)
    fl = np.tanh(0.75 * 9.1204 * lsc_norm ** 2)  # regulates increase of contractility with Ls

    # State variable 1: contractile element length (prevent Lsc from going beyond reference length)
    # const[2]: model.heart.lsc_0, const[6]: model.heart.v_max
    lsc = np.maximum(lsc + dt * (lse_norm - 1) * const[6], 1.0001 * const[2])

    # State variable 2: electrical activation (only for non-ischemic patches)
    # const[4]: model.heart.td, const[5]: model.heart.tr
    c = c + dt * (fl * frise / const[5] - c * gx / const[4])
    # c = c + dt * np.sum(fl[:, np.newaxis] * frise / const[5, np.newaxis].T - c[:, np.newaxis] * gx / const[4, np.newaxis].T, axis=1)

    return c, lsc, ca_cap


@njit(cache=False)
def frise_integral(x):
    return np.exp(-x)*(-0.02*x**5+0.22*x**4-0.4*x**3-1.2*x**2-2.4*x-2.4)


@njit(cache=False)
def v2p(v_chambers, c, lsc, midwall, patches, dt, flags, term_msg, const):
    """
    We first calculate the patch areas and tensions from the contractile element length and contractility. Then we
    calculate the patch areas and tensions from the spherical geometry of the chambers and calculate the final patch areas
    and stretches from the combination of the two.
    Calculate ventricular and atrial kinematics and tension
    :param v_chambers: volumes in the heart chambers
        v_chambers[0]: (model.volumes[bi, 2]) - LV volume
        v_chambers[1]: (model.volumes[bi, 6]) - RV volume
        v_chambers[2]: (model.volumes[bi, 1]) - LA volume
        v_chambers[3]: (model.volumes[bi, 5]) - RA volume
    :param c: (model.heart.c) Contractility
    :param lsc: (model.heart.lsc) Contractile element length
    :param midwall: Array with 6 parameters used for the midwall calculations
        midwall[0]: model.heart.vs
        midwall[1]: model.heart.ys,
        midwall[2]: model.heart.dv,
        midwall[3]: model.heart.dy,
        midwall[4]: 0.5 * (model.heart.vw_w[0] + model.heart.vw_w[2])
        midwall[5]: 0.5 * (model.heart.vw_w[1] + model.heart.vw_w[2])
    :param patches: |model.heart.patches| (21 + 2N,) An array defining whether a patch belong to the left ventricular
        free wall (0), the right ventricular free wall (1), the septal wall (2), the left atrium (3) or the right atrium
        (4).
    :param dt: model.solver.dt (scalar) The time step of the simulation.
    :param flags: (5,) Boolean flags used to control the simulation.
        flags[0]: |model.activation.flag_launch_nsr| Not used in this function.
        flags[1]: |model.activation.flag_launch_af| Not used in this function.
        flags[2]: |model.activation.flag_simulation| Not used in this function.
        flags[3]: False if rhythm='NSR', True if rhythm='AF'. Not used in this function.
        flags[4]: Flag to track whether the simulation was run successfully or was terminated. Default is False. If True,
            then the simulation was terminated for a reason stated in 'term_msg'.
    :param term_msg: Message to inform the user why the simulation was terminated.
    :param const: Matrix with 10 fixed arrays that don't change in the whole simulation.
        const[0]: model.heart.am_ref
        const[1]: model.heart.c_1
        const[2]: model.heart.c_3
        const[3]: model.heart.c_4
        const[4]: model.heart.ls_eiso
        const[5]: model.heart.ls_ref
        const[6]: model.heart.lsc_0
        const[7]: model.heart.sf_act
        const[8]: model.heart.vw
        const[9]: model.heart.v_max
    """
    # Calculate stretch with the contractile element length
    # const[5]: model.heart.ls_ref
    lab_f = lsc / const[5]

    # Active stress
    # const[6]: model.heart.lsc_0, const[7]: model.heart.sf_act
    sf_iso = c * (lsc - const[6]) * const[7]  # Isometric component
    # const[4]: model.heart.ls_eiso, const[5]: model.heart.ls_ref
    siga, dsigadlab_f = sf_iso * 1e-4, (sf_iso * const[5]) / const[4]

    # Passive stress [MPa]
    lab_f2 = lab_f ** 2
    # const[1]: model.heart.c_1, const[2]: model.heart.c_3, const[3]: model.heart.c_4
    sigp = np.minimum(2 * const[1] * (lab_f2 - 1) + const[2] * (np.exp(const[3] * (lab_f2 - 1)) - 1), 1e20)
    # const[1]: model.heart.c_1, const[2]: model.heart.c_3, const[3]: model.heart.c_4
    dsigpdlab_f = np.minimum(4 * const[1] * lab_f + 2 * const[2] * const[3] * lab_f * np.exp(const[3] * (lab_f2 - 1)),
                             1e20)

    # Total stress and its derivative
    sig_f, dsigdlab_f = siga + sigp, dsigpdlab_f + dsigadlab_f

    # Calculate the first version of the patch areas that originate from the contractile element length
    # const[0]: model.heart.am_ref
    am = lab_f ** 2 * const[0]  # Eq 9
    # Calculate the first version of the tension that originates from the contractile element length and contractility
    # const[8]: model.heart.vw
    tm_v1 = sig_f * const[8] / (2 * am)  # Eq 11

    # Patch stiffness and estimated unloaded area
    # const[8]: model.heart.vw
    dadt = 4 * am ** 2 / const[8] / (dsigdlab_f * lab_f - 2 * sig_f)  # Eq 13
    # Calculate the area of the unstressed patches
    am0 = am - tm_v1 * dadt  # Eq 14

    # Wall stiffness and unloaded area, sum of all patches in each wall
    amw0 = np.array([sum(am0[patches == i]) for i in range(0, 5)])
    dadtw = np.array([sum(dadt[patches == i]) for i in range(0, 5)])

    # declare arrays where we only overwrite part of the elements; first the ventricular walls, then the atrial walls
    tm_v2 = np.zeros(5)
    rm = np.zeros(5)

    """
    Below, we calculate the tensions in the ventricular patches from the geometry of the ventricles and apply the Newton
    solver to a balance of forces between the midwall and ventricular free walls. The following code only uses the 
    elements in the numpy arrays that correspond to ventricular patches.
    """
    vs, ys, dv, dy = midwall[0:4]

    # Enclosed midwall volumes of L and R free walls
    vml = v_chambers[0] * 1e3 + midwall[4]
    vmr = v_chambers[1] * 1e3 + midwall[5]

    # Initial estimate of tensions, if error is already below criterion the local solver will be skipped
    tx, ty, tm_v2[0:3], rm[0:3], xm = tension_numba(vs, ys, vml, vmr, amw0[0:3], dadtw[0:3])
    err = err0 = np.linalg.norm(np.array([tx, ty]))  # Get Newton-Raphson error

    # Initialize Newton scheme
    err_max, iter_max, iter = 1e-3, 3, 0
    vs0, ys0 = vs, ys

    while (err > err_max) and (iter < iter_max):
        # Perturb solution
        txv, tyv, _, _, _ = tension_numba(vs + dv, ys, vml, vmr, amw0[0:3], dadtw[0:3])
        txy, tyy, _, _, _ = tension_numba(vs, ys + dy, vml, vmr, amw0[0:3], dadtw[0:3])

        # Inverse Jacobian matrix and determinant
        # try:
        #     dtxdv = (txv - tx) / dv
        # except FloatingPointError as e:
        #     print(f"Error: {e}")
        #     print(f"txv: {txv}, tx: {tx}, dv: {dv}")
        dtxdv = (txv - tx) / dv
        dtydv = (tyv - ty) / dv
        dtxdy = (txy - tx) / dy
        dtydy = (tyy - ty) / dy
        detj = dtxdv * dtydy - dtxdy * dtydv

        # Estimated change in vs and ys
        # If a derivative goes to 0, the solution become unstable and overshoots target values. Prevent this by
        # nudging the next guess away from the unstable point when dv or dy becomes unreasonably large.
        if not detj == 0:
            dv = (-dtydy * tx + dtxdy * ty) / detj
            dy = (+dtydv * tx - dtxdv * ty) / detj
            if np.absolute(dv) > 0.1 * np.absolute(vs):
                dv = np.sign(dv) * vs * 1e-2
            if np.absolute(dy) > 0.1 * np.absolute(ys):
                dy = np.sign(dy) * ys * 1e-2
        else:
            dv = np.sign(dv) * vs * 1e-2
            dy = np.sign(dy) * ys * 1e-2

        # Update solution and state variables
        vs, ys = vs + dv, ys + dy
        tx, ty, tm_v2[0:3], rm[0:3], xm = tension_numba(vs, ys, vml, vmr, amw0[0:3], dadtw[0:3])
        err = np.linalg.norm(np.array([tx, ty]))  # Get Newton-Raphson error

        # Update error if smaller, else perform line search to prevent overshooting minimum
        if err < err0:
            err0, vs0, ys0 = err, vs, ys
        else:
            iter_line = 0
            while (err > err0) and (iter_line < iter_max):
                tx0, ty0, _, _, _ = tension_numba(vs0, ys0, vml, vmr, amw0[0:3], dadtw[0:3])

                # Estimate best line position
                g0 = np.linalg.norm(np.array([tx0, ty0]))  # Get Newton-Raphson error
                g0prime = -g0 / np.linalg.norm(np.array([vs - vs0, ys - ys0]))
                g1 = np.linalg.norm(np.array([tx, ty]))  # Get Newton-Raphson error
                lab = max(-g0prime / (2 * (g1 - g0 - g0prime)), 0.1)

                # New estimates and error
                vs, ys = (1 - lab) * vs0 + lab * vs, (
                        1 - lab) * ys0 + lab * ys
                tx, ty, tm_v2[0:3], rm[0:3], xm = tension_numba(vs, ys, vml, vmr, amw0[0:3], dadtw[0:3])
                err = np.linalg.norm(np.array([tx, ty]))  # Get Newton-Raphson error
                iter_line += 1

        iter += 1
    """
    Below, we calculate the tensions in the atrial patches from the geometry of the atria. The following code only uses 
    the elements in the numpy arrays that correspond to atrial patches.
    """
    # const[8]: model.heart.vw
    vma = np.maximum(v_chambers[2:4] * 1e3, 0) + 0.5 * np.array([sum(const[8, patches == i]) for i in range(3, 5)])
    # rm is radius of chamber with volume vma
    rm[3:5] = ((3 * vma) / (4 * np.pi)) ** (1 / 3)
    # The patches-3 in the square brackets are used because vma/rm is a (2,) nparray. We want that all 3s in patches are
    # used as indices for the element 0 and we want that all 4s in patches are used as indices for the element 1.
    amaw = 3 * (vma / rm[3:5])
    tm_v2[3:5] = (amaw - amw0[3:5]) / dadtw[3:5]

    """
    Calculate the stretch in the patches using the tension from the geometry.
    """
    am = am0 + tm_v2[patches] * dadt
    if np.any(am < 0):
        flags[0:3] = np.array([False, False, False])
        flags[4] = True
        term_msg = "Negative area in patch. The simulation is terminated."
        return lab_f, sig_f, tm_v2, rm, xm, np.array([vs, ys, dv, dy]), flags, term_msg
    lab_f = np.sqrt(am / const[0])

    # Check if model parameters are reasonable and realistic. If the following condition is met, then errors would arise
    # eventually in the following iterations. This can happen if the model parameters chosen before the simulation are
    # unrealistic. If the stretch lab_f is too large here, then the contractile element length lsc will be too large
    # afterwards, then lab_f in the beginning of this function will be too large next iteration, and the computation of
    # the exponential term of sigp and dsigpdlab_f would overflow. Then eventually the simulation continues using NaN and
    # then errors would arise when dividing through parameters set to NaNs. This simulation will be terminated already
    # now if this scenario would occur.
    # The value 709.78 is roughly the largest value for which the exponential function in the computation of sigp in v2p
    # does not overflow. The exact value can be calculated with np.log(np.finfo(np.float64).max).

    # const[4]: model.heart.ls_eiso, const[5]: model.heart.ls_ref
    lse_norm = np.maximum((lab_f * const[5] - lsc) / const[4], 0.0001)  # Normalized series elastic element
    if np.any(709.78 <
              const[3] * ((np.maximum(lsc + dt * (lse_norm - 1) * const[9], 1.0001 * const[6]) / const[5]) ** 2 - 1)):
        flags[0:3] = np.array([False, False, False])
        flags[4] = True
        wall_with_too_large_stretch = patches[709.78 < const[3] * ((np.maximum(lsc + dt * (lse_norm - 1) * const[9],
                                                                                1.0001 * const[6]) / const[5]) ** 2 - 1)]
        if 0 in wall_with_too_large_stretch:
            term_msg = "The stretch lab_f is too large. In wall 0. The simulation is terminated."
        elif 1 in wall_with_too_large_stretch:
            term_msg = "The stretch lab_f is too large. In wall 1. The simulation is terminated."
        elif 2 in wall_with_too_large_stretch:
            term_msg = "The stretch lab_f is too large. In wall 2. The simulation is terminated."
        elif 3 in wall_with_too_large_stretch:
            term_msg = "The stretch lab_f is too large. In wall 3. The simulation is terminated."
        elif 4 in wall_with_too_large_stretch:
            term_msg = "The stretch lab_f is too large. In wall 4. The simulation is terminated."

    return lab_f, sig_f, tm_v2, rm, xm, np.array([vs, ys, dv, dy]), flags, term_msg


@njit(cache=False)
def update_pericardium_pressure(v_sum, const):
    """
    :param v_sum: sum(v[bi, [1, 2, 5, 6]])
    :param const: Array with 7 parameters used to update the pericardium pressure
        const[0]: model.pericardium.c_1
        const[1]: model.pericardium.c_3
        const[2]: model.pericardium.c_4
        const[3]: model.pericardium.lab_pre
        const[4]: model.pericardium.thickness
        const[5]: model.heart.v_tot_0
        const[6]: sum(model.heart.vw_w)
    """
    # Compute pericardial kinematics: total heart volume [mm^3] and pericardial stretch [0]
    # const[6]: sum(model.heart.vw_w)
    v_heart = v_sum * 1e3 + const[6]
    # const[4]: model.pericardium.thickness
    if const[4] > 0.0:
        # const[3]: model.pericardium.lab_pre, const[5]: model.heart.v_tot_0
        p__lab_f = (v_heart / const[5]) ** ((1 / 3) * const[3])
    else:
        p__lab_f = 1.0  # Prevent potential crashes when not using pericardium

    # Pericardial pressure [mmHg], via thin-walled sphere theory
    p__lab_f2 = p__lab_f ** 2
    # const[0]: model.pericardium.c_1, const[1]: model.pericardium.c_3, const[2]: model.pericardium.c_4
    sig_p = np.minimum(2 * const[0] * (p__lab_f2 - 1) + const[1] * (np.exp(const[2] * (p__lab_f2 - 1)) - 1),
                       1e20)  # Stress [MPa]
    r_p = (3 * v_heart) / (4 * np.pi) ** (1 / 3)
    # const[4]: model.pericardium.thickness
    p__pressure = 2 * sig_p * const[4] / r_p * 7.5e3
    return p__pressure, p__lab_f


def call_simulation(model):
    """
    This function is just a wrapper function to write the model parameters from the class object into parameters that
    numba can handle. To read the code of the simulation, jump to 'run_simulation'. More details about each parameter are
    given in the docstring of the 'run_simulation' function.
    """
    # First we automatically determine the absolute path for the cardiogrowth_py folder. I don't want to set an absolute
    # path here manually, because different users might have the cardiogrowth function stored in different locations. The
    # problem that I am having is that if a cardiomatch function is calling 'rhythm_is_a_dancer' and cardiomatch and
    # cardiogrowth are stored separately, the os.getcwd() function returns the path to cardiomatch instead of
    # cardiogrowth. I am sorting this problem out here.
    path = os.getcwd()
    path = (path[:path.rfind('/Computational_model_of_haemodynamics_during_atrial_fibrillation')] +
            '/Computational_model_of_haemodynamics_during_atrial_fibrillation')

    volumes = model.volumes
    pressures = model.pressures
    contractility = model.contractility
    sarcomere_length = model.sarcomere_length
    tension = model.tension
    lab_f__h = model.heart.lab_f
    sig_f__h = model.heart.sig_f
    t_act = model.activation.t_act
    ca_cap = np.zeros(t_act.shape)
    rm__h = model.heart.rm
    xm__h = model.heart.xm
    lab_f__p = model.pericardium.lab_f
    pressures__p = model.pericardium.pressure
    next_act = model.activation.next_his_activation_time
    act = model.activation.his_activation_counter
    last_gauss = model.activation.last_gauss
    sigma_ventr = model.activation.sigma_ventr
    sigma_atria = model.activation.sigma_atria
    if ~np.isnan(model.activation.num_beats_af_launch):
        vat = np.concatenate([model.activation.vat_series_af_launch, model.activation.vat_series])
        rr = np.concatenate([model.activation.rr_series_af_launch, model.activation.rr_series])
    else:
        vat = model.activation.vat_series
        rr = model.activation.rr_series
    avn_states = np.concatenate((model.activation.rt, model.activation.dt,
                                 np.array([model.activation.aat, model.activation.node0_n_imp,
                                           model.activation.beats_to_draw])))
    avn_q = model.activation.q
    phases = model.activation.phases
    vat0_time = -model.solver.dt
    dt = model.solver.dt
    patches = model.heart.patches
    iv = model.heart.i_ventricles
    bi = model.solver.batch_inc
    # Load v, v_conv, c, lsc, vs, ys, dv, and dy from a converged solution.
    if model.activation.use_converged:
        with open(path + '/io/converged_rhythm.pkl', 'rb') as converged_sol_file:
            converged_sol = pickle.load(converged_sol_file)
        # Choose the row in the converged solution array that corresponds to a heart rate closest to what we want to
        # simulate.
        converged_sol = converged_sol[converged_sol[:, 0] == np.round(60000/model.activation.rr_char[0])][0]
        v = converged_sol[1:9]
        v_conv = converged_sol[9:17]
        # The reformat_mask changes the shape of c__h and lsc__h in case the number of atrial patches is >1.
        reformat_mask = np.arange(model.heart.n_patches_tot)
        reformat_mask[21:(21 + int(model.heart.n_patches[3]))] = 21
        reformat_mask[(21 + int(model.heart.n_patches[3])):] = 22
        c__h = converged_sol[17:40][reformat_mask]
        lsc__h = converged_sol[40:63][reformat_mask]
        model.heart.vs = converged_sol[63]
        model.heart.ys = converged_sol[64]
        model.heart.dv = converged_sol[65]
        model.heart.dy = converged_sol[66]
    else:  # No converged solution is used
        v = model.volumes[0].copy()
        v_conv = model.volumes[0].copy()
        c__h = model.heart.c
        lsc__h = model.heart.lsc
    midwall = np.array([model.heart.vs, model.heart.ys, model.heart.dv, model.heart.dy,
                        0.5 * (model.heart.vw_w[0] + model.heart.vw_w[2]),
                        0.5 * (model.heart.vw_w[1] + model.heart.vw_w[2])])
    if model.activation.rhythm == 'NSR':
        flags = np.array([model.activation.flag_launch_nsr, model.activation.flag_launch_af,
                          model.activation.flag_simulation, False, model.termination.terminated])
    else:  # model.activation.rhythm == 'AF':
        flags = np.array([model.activation.flag_launch_nsr, model.activation.flag_launch_af,
                          model.activation.flag_simulation, True, model.termination.terminated])
    term_msg = model.termination.message
    v2p_constants = np.array([model.heart.am_ref, model.heart.c_1, model.heart.c_3, model.heart.c_4, model.heart.ls_eiso,
                              model.heart.ls_ref, model.heart.lsc_0, model.heart.sf_act, model.heart.vw,
                              model.heart.v_max])
    per_constants = np.array([model.pericardium.c_1, model.pericardium.c_3, model.pericardium.c_4,
                              model.pericardium.lab_pre, model.pericardium.thickness, model.heart.v_tot_0,
                              sum(model.heart.vw_w)])
    cap = np.array([model.capacitances.cvp,  # cap[0]
                    model.capacitances.cas,  # cap[1]
                    model.capacitances.cvs,  # cap[2]
                    model.capacitances.cap])  # cap[3]
    con_constants = np.array([model.heart.ls_eiso, model.heart.ls_ref, model.heart.lsc_0, model.heart.t_ad,
                                      model.heart.td, model.heart.tr, model.heart.v_max])
    phase_constants = np.array([model.solver.cutoff, model.solver.nsr_launch_iter_max,
                                model.activation.num_beats_af_launch, model.activation.num_beats])
    act_constants = np.concatenate((model.activation.avn_rp, model.activation.avn_cd, model.activation.avn_resp,
                                    model.activation.p4dist,
                                    np.array([model.activation.rr_char[0], model.activation.num_draw_beats_at_once])))
    vol_constants = np.array([model.resistances.rap,
                              model.resistances.ras,
                              model.resistances.rav,
                              model.resistances.rcp,
                              model.resistances.rcs,
                              model.resistances.rmvb,
                              model.resistances.rtvb,
                              model.resistances.rvp,
                              model.resistances.rvs,
                              model.circulation.sbv])

    pickle_iter = 0
    temp_folder_name = None
    simulation_failed = False  # This flag is to catch a zero division error for which the simulation failed and a
    # termination flag is set to True
    while flags[2]:
        try:
            (volumes, pressures, lab_f__h, sig_f__h, c__h, lsc__h, t_act, rm__h, xm__h, lab_f__p, pressures__p, next_act,
             act, last_gauss, vat, rr, contractility, sarcomere_length, tension, avn_states, avn_q, phases, vat0_time,
             bi, v, v_conv, midwall, ca_cap, flags, term_msg) = (
                run_simulation(volumes, pressures, lab_f__h, sig_f__h, c__h, lsc__h, t_act, rm__h, xm__h, lab_f__p,
                               pressures__p, next_act, act, last_gauss, sigma_ventr, sigma_atria, vat, rr, avn_states,
                               avn_q, phases, vat0_time, dt, contractility, sarcomere_length, tension, patches, iv, bi,
                               v, v_conv, midwall, ca_cap, flags, term_msg, v2p_constants, per_constants, cap, con_constants,
                               phase_constants, act_constants, vol_constants))
        except ZeroDivisionError:
            simulation_failed = True
            flags[2] = False
        if not simulation_failed:
            if flags[2]:  # Only store simulation results in a file, if the simulation will be continued.
                # Save the model object
                if temp_folder_name is None:
                    temp_folder_name = os.path.join(path, 'io/temp_data/', str(uuid.uuid4()))
                    os.makedirs(temp_folder_name)
                with open(temp_folder_name + '/batch_' + str(pickle_iter) + '.pkl', 'wb') as file:
                    pickle.dump(np.concatenate((volumes, pressures, rm__h, xm__h, lab_f__p[:, np.newaxis],
                                                pressures__p[:, np.newaxis], phases[:, np.newaxis], lab_f__h,
                                                sig_f__h, contractility, sarcomere_length, tension), axis=1), file)
                pickle_iter += 1
                bi = 0
            else:  # The simulation is finished, so we write the results back into the model object.
                if pickle_iter:  # In this case, we have stored simulation results in files and need to load them.
                    # Here in case we generated GBs of data, and want to do some processing that reduces the size of the
                    # dataset, we could also do the processing for each individual batch to avoid loading too much into
                    # memory.
                    pickled_data = np.zeros((pickle_iter * model.solver.batch_size + bi, 27 + 4 * model.heart.n_patches_tot + 5))
                    for i in range(pickle_iter):
                        with open(temp_folder_name + '/batch_' + str(i) + '.pkl', 'rb') as file:
                            pickled_data[i * model.solver.batch_size:(i + 1) * model.solver.batch_size] = pickle.load(file)
                    shutil.rmtree(temp_folder_name)
                    pickled_data[pickle_iter * model.solver.batch_size:] = (
                        np.concatenate((volumes[:bi], pressures[:bi], rm__h[:bi], xm__h[:bi],
                                        lab_f__p[:bi, np.newaxis], pressures__p[:bi, np.newaxis], phases[:bi, np.newaxis],
                                        lab_f__h[:bi], sig_f__h[:bi], contractility[:bi], sarcomere_length[:bi],
                                        tension[:bi]), axis=1))
                    if model.activation.keep_simulation_data == 0:  # keep_simulation_data == 'all'
                        start = 0
                    else:  # model.activation.keep_simulation_data == 1:  # keep_simulation_data == 'no_launch'
                        # Same as ~(model.activation.rhythm == 'NSR' and model.activation.num_beats == 0):
                        if model.activation.rhythm == 'AF' or model.activation.num_beats > 0:
                            start = np.argmax(pickled_data[:, 26] == 2)  # np.argmax(phases == 2)
                        else:  # model.activation.rhythm == 'NSR' and model.activation.num_beats == 0
                            start = int(bi-np.ceil(model.activation.rr_char[0]/model.solver.dt))
                    model.volumes = pickled_data[start:, 0:8]
                    model.pressures = pickled_data[start:, 8:16]
                    model.contractility = pickled_data[start:, 27 + 2 * model.heart.n_patches_tot:27 + 3 * model.heart.n_patches_tot]
                    model.sarcomere_length = pickled_data[start:, 27 + 3 * model.heart.n_patches_tot:27 + 4 * model.heart.n_patches_tot]
                    model.tension = pickled_data[start:, 27 + 4 * model.heart.n_patches_tot:]
                    model.heart.lab_f = pickled_data[start:, 27:27 + model.heart.n_patches_tot]
                    model.heart.sig_f = pickled_data[start:, 27+model.heart.n_patches_tot:27 + 2 * model.heart.n_patches_tot]
                    model.heart.rm = pickled_data[start:, 16:21]
                    model.heart.xm = pickled_data[start:, 21:24]
                    model.pericardium.lab_f = pickled_data[start:, 24]
                    model.pericardium.pressure = pickled_data[start:, 25]
                    model.activation.phases = pickled_data[start:, 26]
                else:  # We have not stored any data in a file, so we write the results directly from the output parameters.
                    if model.activation.keep_simulation_data == 0:  # keep_simulation_data == 'all'
                        start = 0
                    else:  # model.activation.keep_simulation_data == 1:  # keep_simulation_data == 'no_launch'
                        # Same as ~(model.activation.rhythm == 'NSR' and model.activation.num_beats == 0):
                        if model.activation.rhythm == 'AF' or model.activation.num_beats > 0:
                            start = np.argmax(phases[:bi] == 2)
                        else:  # model.activation.rhythm == 'NSR' and model.activation.num_beats == 0
                            # Get the starting index by subtracting one heart beat from the last iteration
                            start = int(bi-np.ceil(model.activation.rr_char[0]/model.solver.dt))
                    model.volumes = volumes[start:bi]
                    model.pressures = pressures[start:bi]
                    model.contractility = contractility[start:bi]
                    model.sarcomere_length = sarcomere_length[start:bi]
                    model.tension = tension[start:bi]
                    model.heart.lab_f = lab_f__h[start:bi]
                    model.heart.sig_f = sig_f__h[start:bi]
                    model.heart.rm = rm__h[start:bi]
                    model.heart.xm = xm__h[start:bi]
                    model.pericardium.lab_f = lab_f__p[start:bi]
                    model.pericardium.pressure = pressures__p[start:bi]
                    model.activation.phases = phases[start:bi]

    if not simulation_failed:
        model.heart.c = c__h
        model.heart.lsc = lsc__h
        model.activation.t_act = t_act
        model.activation.next_his_activation_time = next_act
        model.activation.his_activation_counter = act
        model.activation.rt = avn_states[0:22]
        model.activation.dt = avn_states[22:44]
        model.activation.aat = avn_states[44]
        model.activation.node0_n_imp = avn_states[45]
        model.activation.beats_to_draw = avn_states[46]
        model.activation.q = avn_q
        if ~np.isnan(model.activation.num_beats_af_launch):
            model.activation.vat_series_af_launch = vat[:model.activation.num_beats_af_launch]
            model.activation.vat_series = (vat[model.activation.num_beats_af_launch:] -
                                           vat[model.activation.num_beats_af_launch])
            model.activation.rr_series_af_launch = rr[:model.activation.num_beats_af_launch]
            model.activation.rr_series = rr[model.activation.num_beats_af_launch:]
            model.activation.rt[1:] -= vat[model.activation.num_beats_af_launch]
            model.activation.aat -= vat[model.activation.num_beats_af_launch]
            for row_idx, row in enumerate(model.activation.q):
                model.activation.q[row_idx] = (row[0] - vat[model.activation.num_beats_af_launch], row[1])
        else:
            model.activation.vat_series = vat
            model.activation.rr_series = rr
        model.activation.time = np.flip(-np.arange(model.volumes.shape[0])*model.solver.dt) + vat0_time
        model.solver.batch_inc = bi
        model.heart.vs = midwall[0]
        model.heart.ys = midwall[1]
        model.heart.dv = midwall[2]
        model.heart.dy = midwall[3]
        model.activation.flag_launch_nsr = flags[0]
        model.activation.flag_launch_af = flags[1]
        model.activation.flag_simulation = flags[2]
        model.termination.terminated = flags[4]
        model.termination.message = term_msg

        # We need this parameter for the generation of the converged solution for the NSR launch phase.
        model.activation.next_volume = v

        # We need at least 3 heart beats to calculate RR rmssd and at least 5 heart beats to calculate RR sample entropy.
        # Note, that the estimates of RR rmssd and RR sample entropy only get robust with more heart beats (>200).
        # We calculate the RR rmssd and RR sample entropy for fewer beats anyway, because the computation is fast.
        if model.activation.num_beats > 4:  # We need at least 5 beats to not get a zero-division error, because m=2 in
            model.activation.rr_char = np.array([np.mean(model.activation.rr_series), rmssd(model.activation.rr_series),
                                                 sample_entropy(model.activation.rr_series)])
        elif model.activation.num_beats > 2:
            model.activation.rr_char = np.array([np.mean(model.activation.rr_series), rmssd(model.activation.rr_series),
                                                 np.nan])
        elif model.activation.num_beats > 1:
            model.activation.rr_char = np.array([np.mean(model.activation.rr_series), np.nan, np.nan])
        else:
            model.activation.rr_char[1:3] = np.nan
    else:  # simulation has failed
        model.termination.terminated = True
        model.termination.message = "A zero division error occurred. The simulation is terminated."
